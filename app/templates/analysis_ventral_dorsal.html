<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ANÁLISIS VENTRAL-DORSAL</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN"
      crossorigin="anonymous"
    />
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../static/css/analysis_ventral.css" />
    <style>
      #videoFeed {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform: scaleX(-1);
        z-index: 1;
        object-fit: cover;
      }
      #output_canvas {
        transform: scaleX(-1);
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 2;
        pointer-events: none;
      }
      #container-video {
        display: none;
        position: relative;
        width: 100%;
        height: 380px;
      }
      .container-live {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body id="root">
    <div class="container" id="container">
      <header>
        <h1 class="text-center">ANÁLISIS VENTRAL - DORSAL</h1>
      </header>
      <button id="backImg" class="btn btn-light btn-left-top">
        <i class="bi bi-arrow-left"></i>
      </button>
      <div class="info-img-box" id="infoImgBox">
        <i class="bi bi-info-circle"></i>
        La imagen de la persona debe ser de cuerpo entero con torso desnudo, o
        con ropa ajustada contrastada con el fondo. Preferentemente de espalda a
        la cámara.
      </div>
      <div class="info-box" id="infoBox">
        <i class="bi bi-info-circle"></i>
        Debe marcar los primeros 2 puntos; a la altura del acromion de ambas
        escápulas de la persona.Y los siguientes 2 puntos; a la altura del punto
        más superior de las crestas ilíacas izquierda y derecha para realizar el
        análisis.
      </div>
      <div class="container-card" id="containerCard">
        <div class="card">
          <button type="button" id="uploadButton" class="custom-upload">
            <i class="bi bi-camera"></i>
            Subir imagen
          </button>
          <input
            type="file"
            id="uploadImage"
            name="image"
            style="display: none"
            accept="image/*"
            onchange="handleImageUpload(event)"
          />
        </div>
        <div class="card">
          <button type="button" id="liveAnalysisBtn" class="custom-upload">
            <i class="bi bi-camera-video"></i>
            Análisis en vivo
          </button>
        </div>
      </div>
      <canvas id="canvas"></canvas>
      <div class="button-container">
        <button
          type="button"
          id="removeLastPoint"
          class="btn btn-light remove-button"
          onclick="handleRemoveLastPoint()"
        >
          <i class="bi bi-arrow-left"></i>
          Remover ultimo punto
        </button>
        <button
          type="button"
          id="analyzeButton"
          class="button btn btn-outline-success btn-custom"
        >
          Analizar puntos
        </button>
      </div>
      <div class="container-live" id="containerLive">
        <div class="container" id="container-video">
          <video id="videoFeed" autoplay alt="Video en vivo"></video>
          <canvas id="output_canvas"></canvas>
        </div>
        <button id="captureImageButton" class="button">Capturar</button>
        <img id="capturedImage" alt="Imagen Capturada" />
        <ul id="angleList" class="angle-list"></ul>
      </div>

      <a
        href="{{ url_for('analysis_selection') }}"
        class="btn btn-light btn-bottom-left"
      >
        <i class="bi bi-arrow-left"></i> Volver a sección de análisis
      </a>
    </div>
    <footer>
      <p>&copy; 2024 KiEs. Todos los derechos reservados.</p>
    </footer>
    <script src="../static/js/analysis_ventral/script.js"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL"
      crossorigin="anonymous"
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils"></script>

    <script>
      const videoElement = document.getElementById("videoFeed");

      navigator.mediaDevices
        .getUserMedia({ video: true })
        .then((stream) => {
          videoElement.srcObject = stream;
        })
        .catch((error) => {
          console.error("Error al acceder a la cámara:", error);
        });

      const pose = new Pose({
        locateFile: (file) =>
          `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`,
      });
      pose.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        enableSegmentation: false,
        smoothSegmentation: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });

      pose.onResults(onResults);

      function onResults(results) {
        const canvasElement = document.getElementById("output_canvas");
        const canvasCtx = canvasElement.getContext("2d");
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

        if (results.poseLandmarks) {
          drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, {
            color: "#00FF00",
            lineWidth: 1,
          });
          drawLandmarks(results.poseLandmarks);
        }
      }

      function drawLandmarks(landmarks) {
        const canvasElement = document.getElementById("output_canvas");
        const canvasCtx = canvasElement.getContext("2d");

        const leftShoulder = landmarks[11];
        const rightShoulder = landmarks[12];
        const leftHip = landmarks[23];
        const rightHip = landmarks[24];

        const shoulderAngle = calculateAngle(leftShoulder, rightShoulder);
        const hipAngle = calculateAngle(leftHip, rightHip);

        canvasCtx.strokeStyle = "red";
        canvasCtx.lineWidth = 1;

        // Dibujar líneas de referencia
        canvasCtx.beginPath();
        canvasCtx.moveTo(
          leftShoulder.x * canvasElement.width,
          leftShoulder.y * canvasElement.height
        );
        canvasCtx.lineTo(
          rightShoulder.x * canvasElement.width,
          leftShoulder.y * canvasElement.height
        );
        canvasCtx.stroke();

        canvasCtx.beginPath();
        canvasCtx.moveTo(
          leftHip.x * canvasElement.width,
          leftHip.y * canvasElement.height
        );
        canvasCtx.lineTo(
          rightHip.x * canvasElement.width,
          leftHip.y * canvasElement.height
        );
        canvasCtx.stroke();

        // Mostrar ángulos en la esquina superior izquierda del canvas
        canvasCtx.save(); // Guardar el estado del contexto
        canvasCtx.scale(-1, 1); // Reflejar el contenido horizontalmente
        canvasCtx.fillStyle = "red";
        canvasCtx.font = "8px Arial";
        canvasCtx.fillText(
          `Ángulo de Hombros: ${Math.round(shoulderAngle)}°`,
          -canvasElement.width + 0,
          8
        );
        canvasCtx.fillText(
          `Ángulo de Caderas: ${Math.round(hipAngle)}°`,
          -canvasElement.width + 0,
          20
        );
        canvasCtx.restore(); // Restaurar el estado original del contexto
      }

      function calculateAngle(point1, point2) {
        const dy = point2.y - point1.y;
        const dx = point2.x - point1.x;

        const angle = Math.atan2(dy, dx) * (180 / Math.PI);

        // Ajustar el ángulo para que sea 0° cuando ambas líneas estén alineadas horizontalmente
        if (angle < 0) {
          return 180 + angle; // Convertir ángulos negativos a su representación positiva
        }
        return angle;
      }

      async function detectPose() {
        await pose.send({ image: videoElement });
        requestAnimationFrame(detectPose);
      }

      videoElement.onloadeddata = () => {
        detectPose();
      };

      captureImageButton.addEventListener("click", () => {
        event.preventDefault();
        captureImageFromFeed();
      });

      function captureImageFromFeed() {
        // Crear un canvas temporal
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");

        // Establecer el tamaño del canvas temporal igual al tamaño del video o del output_canvas
        canvas.width = videoElement.videoWidth;
        canvas.height = videoElement.videoHeight;

        // Dibujar el video en el canvas temporal
        context.drawImage(videoElement, 0, 0, canvas.width, canvas.height);

        // Dibujar el contenido del output_canvas encima del video
        const outputCanvas = document.getElementById("output_canvas");
        context.drawImage(outputCanvas, 0, 0, canvas.width, canvas.height);

        // Convertir el canvas temporal en una URL de imagen
        const imageURL = canvas.toDataURL("image/png");

        // Asignar la URL de imagen al elemento img para mostrar la captura
        const capturedImage = document.getElementById("capturedImage");
        capturedImage.src = imageURL;
        capturedImage.style.display = "block"; // Mostrar la imagen capturada
      }
    </script>
  </body>
</html>
